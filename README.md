
# Async_assigment
## Асинхронні запити в Unity: Тред блокінг

У цьому посібнику ви навчитеся виконувати асинхронні запити в Unity та зрозумієте, 
як неправильна робота з тредами може блокувати головний тред Unity. 
Ми розглянемо три сценарії: запит у головному треді, запит через корутину, і запит з використанням ***Task.Run***.

### Сценарій 1: Блокування головного треду
#### Опис

Цей сценарій демонструє, що відбувається, коли HTTP-запит виконується безпосередньо в головному треді Unity. 
Через затримку, викликану запитом, весь рендеринг та анімація призупиняються.

#### Код

```C#
using System;
using System.Threading;
using UnityEngine;

public class MainThreadBlocking : MonoBehaviour
{
    void Start()
    {
        // Стартуємо рух куба
        StartCoroutine(MoveCube());
        
        // Виконуємо запит в головному треді з штучною затримкою
        Debug.Log("Запит почався...");
        Thread.Sleep(3000); // Штучна затримка для блокування
        Debug.Log("Запит завершився...");
    }

    IEnumerator MoveCube()
    {
        while (true)
        {
            transform.position += Vector3.forward * Time.deltaTime;
            yield return null;
        }
    }
}
```
#### Sequence Diagram
![first diagram](img/screen1.png)
##### Generating PlantUML diagram

### Сценарій 2: Використання корутин
#### Опис
У цьому сценарії ми використовуємо корутину для виконання запиту. 
Попри поширену думку, корутина не вирішує проблему блокування треду, 
якщо у ній використовуються блокуючі методи.

#### Код
```C#
using System;
using System.Threading;
using UnityEngine;

public class CoroutineBlocking : MonoBehaviour
{
    void Start()
    {
        // Стартуємо рух куба
        StartCoroutine(MoveCube());
        
        // Виконуємо запит через корутину з штучною затримкою
        StartCoroutine(FakeHttpRequest());
    }

    IEnumerator FakeHttpRequest()
    {
        Debug.Log("Запит почався...");
        Thread.Sleep(3000); // Штучна затримка, що блокує тред
        Debug.Log("Запит завершився...");
        yield return null;
    }

    IEnumerator MoveCube()
    {
        while (true)
        {
            transform.position += Vector3.forward * Time.deltaTime;
            yield return null;
        }
    }
}
```
#### Sequence Diagram
![second diagram](img/screen2.png)
##### Generating PlantUML diagram

### Сценарій 3: Використання Task.Run
#### Опис
Цей сценарій демонструє правильний підхід до виконання тривалих операцій у Unity. 
Ми використовуємо Task.Run, щоб виконати запит в окремому треді, 
уникаючи блокування головного треду.

#### Код
```C#
using System;
using System.Threading.Tasks;
using UnityEngine;

public class TaskRunExample : MonoBehaviour
{
    void Start()
    {
        // Стартуємо рух куба
        StartCoroutine(MoveCube());
        
        // Виконуємо запит через Task.Run
        Task.Run(() => FakeHttpRequest());
    }

    async Task FakeHttpRequest()
    {
        Debug.Log("Запит почався...");
        await Task.Delay(3000); // Штучна затримка, яка не блокує головний тред
        Debug.Log("Запит завершився...");
    }

    IEnumerator MoveCube()
    {
        while (true)
        {
            transform.position += Vector3.forward * Time.deltaTime;
            yield return null;
        }
    }
}
```
#### Sequence Diagram
![third diagram](img/screen3.png)
##### Generating PlantUML diagram

## Висновок
Цей посібник показав три підходи до виконання HTTP-запитів у Unity, 
пояснивши, чому важливо виконувати тривалі операції в окремих тредах, 
щоб уникнути блокування головного треду Unity. За допомогою коректного використання асинхронності 
та Task.Run можна досягти плавної роботи додатку без заморожування анімацій або рендерингу.

## Завдання
- [x] Створити сцену в юніті, прикріпити TaskRunExample до кубу
- [x] (опціонально) протестити роботу блокування мейн треба з корутиною і без

- [x] Подумати, як потрібно змінити TaskRunExample, 
якби ми отримували якусь реальну інформацію, наприклад список імен друзів плеєра, 
при цьому бажаючи не блокувати основний тред, реалізувати придуману модифікацією
ознайомитись з json utility
- [x] зробити фейковий json файл, що містить імена друзів плеєра, спробувати зчитати з нього інформацію в програмі
- [x] (опціонально, завдання з зірочкою) завантажити джейсон файл в інтернет, є безліч фейк джсон серверів, і спробувати надіслати гет реквест для отримання даних
примітка: насправді існує зручніший спосіб це зробити в корутині, про який знизу

# Використання Coroutine та Yield для очікування веб-запиту в Unity
У цьому додатку ми детально розглянемо, як працює механізм корутин у Unity та як 
правильно використовувати yield для асинхронного виконання веб-запитів. 
Це підхід дозволяє виконувати запити без блокування головного треду, 
зберігаючи при цьому плавність виконання інших задач, таких як рендеринг.

## Як працює Coroutine
Корутина в Unity — це спеціальний метод, який дозволяє призупиняти виконання коду 
і продовжувати його виконання у наступних кадрах. Це корисно, коли потрібно виконувати тривалі операції (наприклад, завантаження даних), не блокуючи головний тред гри.

### Основні концепції:
+ yield: Використовується для того, щоб призупинити виконання корутини до певної події або до наступного кадру.
+ Асинхронність: Корутини дозволяють робити асинхронні операції, наприклад, завантаження файлів, виконання запитів до серверів і т.д.
+ Перевага: Ви можете виконувати завдання в бекграунді, не зупиняючи роботу головного треду.

### Приклад використання корутини для HTTP-запиту
У цьому прикладі ми використовуємо UnityWebRequest разом з корутиною, щоб виконати асинхронний запит до сервера. За допомогою yield return ми можемо призупинити виконання коду, поки запит не завершиться.

#### Код
```C#
using System.Collections;
using UnityEngine;
using UnityEngine.Networking;

public class WebRequestCoroutine : MonoBehaviour
{
    void Start()
    {
        // Викликаємо корутину для асинхронного запиту
        StartCoroutine(GetDataFromServer());
    }

    IEnumerator GetDataFromServer()
    {
        string url = "https://jsonplaceholder.typicode.com/posts/1";
        
        // Створюємо запит
        UnityWebRequest request = UnityWebRequest.Get(url);

        // Використовуємо yield, щоб чекати, поки запит не завершиться
        yield return request.SendWebRequest();

        // Перевіряємо чи не виникла помилка
        if (request.result != UnityWebRequest.Result.Success)
        {
            Debug.LogError("Помилка: " + request.error);
        }
        else
        {
            // Отримуємо результат
            Debug.Log("Дані з сервера: " + request.downloadHandler.text);
        }
    }
}
```

### Пояснення коду:
1. **Запуск корутини:**
У методі Start ми викликаємо корутину GetDataFromServer() за допомогою StartCoroutine(). Це дозволяє нам виконати запит у фоновому режимі.

Створення запиту:
Ми використовуємо UnityWebRequest для створення HTTP GET-запиту до URL.

Використання yield return:
Виклик yield return request.SendWebRequest() призупиняє виконання корутини, поки запит не завершиться. Unity продовжить виконання інших завдань, і коли запит завершиться, корутина відновить роботу з того місця, де була зупинена.

Обробка результату:
Після завершення запиту ми перевіряємо результат і виводимо дані або повідомлення про помилку.

Переваги корутин для веб-запитів
Корутини особливо корисні у випадках, коли потрібно виконувати тривалі або асинхронні операції, такі як:

HTTP-запити
Завантаження файлів
Затримки між діями
Використовуючи корутини, ви можете уникнути блокування головного треду, забезпечуючи плавний рендеринг сцени і інші операції гри.

Як працює yield return
Пояснення механізму
Коли ви використовуєте yield return в корутині, ви фактично кажете Unity: "Зупини виконання цього методу до певного моменту, потім продовжуй". Unity автоматично обробляє такі зупинки і продовжує виконання корутин у наступних кадрах. Це дозволяє уникати тривалих блокувань.

Наприклад, у випадку з yield return request.SendWebRequest(), Unity зупиняє виконання корутини, доки веб-запит не завершиться, а потім відновлює роботу, як тільки запит завершиться.